/*
Written by: James Wigglesworth 
Started: 5_21_19
Updated: 10_14_19

Overview:
#A User Input
#B Globals
#C init_globals()
#D init_robot()
#E find_idx_eyes()
	#E1 is_idx_eye()
    #E2 AdcCenters string conversions
#F set_found_position()
#G Find_Idx_Eyes Job Def
#H Test_All_States Job Def
*/


/*
w, 42, 832
make_ins('w', 42, 832)
set eye number
set commanded angle
*/


//#A User Input:
var initial_direction = [-1, -1, -1, 1, -1]
var slow_step_size = [1000*_arcsec, 1000*_arcsec, 1000*_arcsec, 1000*_arcsec,  1000*_arcsec]//[0, 0, 0, 0, 100*_arcsec]
var rapid_steps_per_eye = [15, 15, 15, 15, 15]
var idid = 0
var n_eyes = [200, 180, 157, 113, 100]
var max_eye_spacing = [30, 30, 30, 30, 14]

//var idx_eye_to_cal_offset = [5, -6, 8, -5, 0]
//var idx_eye_to_cal_offset = [0, 0, 0, 0, 0]
// out(Vector.subtract([255, 255, 255, 255, 255], true_home_eye))
//var post_cal_info = JSON.parse(file_content("C:/Users/james/Documents/dde_apps/2019/_Code/Misc/EncoderIdeas/on_bootup_info"))
var tweek_angles = [5.5125, 0.03333333333333333, 0.0225, 0.013125, 0.046875]
var file_on_dexter_name = "/srv/samba/share/Index_Eye_Data.JSON"
var file_on_dexter_name_post_cal = "/srv/samba/share/post_cal_info.JSON"

/*
var temp = [
	Dexter.dexter0.robot_status[Dexter.J1_ANGLE],
    Dexter.dexter0.robot_status[Dexter.J2_ANGLE],
    Dexter.dexter0.robot_status[Dexter.J3_ANGLE],
    Dexter.dexter0.robot_status[Dexter.J4_ANGLE],
    Dexter.dexter0.robot_status[Dexter.J5_ANGLE]
]
*/
//#B Globals:
var deg_per_eye
var step_size
var start_time
var start_EyeNumber
var old_EyeNumber
var old_RawEncoder
var AdcCenters_array
var prev_eye_cos_vals
var prev_eye_sin_vals
var cur_commanded_pos
var cos_maxes
var sin_maxes
var cur_direction
var first_idx_eye
var second_idx_eye
var spacing_to_eye_offset
var final_eye_offset
var cos_to_center_block_offset
//var cw_spacing_to_eye_offset
//var ccw_spacing_to_eye_offset
var spacing_idx
var final_angle_offset
var stage_idx
var stage_string_array
var true_home_eye
var neg_spacing_to_eye_offset
var pos_spacing_to_eye_offset
var all_cos_vals
var all_sin_vals
var all_eyes

var scan_data
var scan_result
var cos_diff_thres
var sin_diff_thres
var eyes_between_sensors
var info_raw_idx_eye
var info_post_calibration
//var idx_eye_to_cal_offset
var EyeNumber
var waiting_eyes
var all_waiting
var idx_eye_to_cal_offset
var post_cal_info
var goal_angle_in_eye


//idx: [255, 261, 247, 261, 256]
//cal: [258,255,255,255,255]
//var diff = Vector.subtract([258,255,255,255,255], [255, 261, 247, 261, 256])

//#C init_globals():
function init_globals(){    
    deg_per_eye = Vector.divide(360, n_eyes)
    step_size = Vector.multiply(Vector.abs(slow_step_size), initial_direction)
    prev_eye_cos_vals = [[], [], [], [], []]
    prev_eye_sin_vals = [[], [], [], [], []]
    all_cos_vals = [[], [], [], [], []]
    all_sin_vals = [[], [], [], [], []]
    all_eyes = [[], [], [], [], []]
    cos_maxes = [[], [], [], [], []]
    sin_maxes = [[], [], [], [], []]
    cur_commanded_pos = [0, 0, 0, 0, 0]
    cur_direction = JSON.parse(JSON.stringify(initial_direction))
    first_idx_eye = [0, 0, 0, 0, 0]
    second_idx_eye = [0, 0, 0, 0, 0]
    final_eye_offset = [0, 0, 0, 0, 0]
    spacing_to_eye_offset = [0]
    spacing_idx = [0, 0, 0, 0, 0]
    smart_scan_results = []
    smart_scan_found_eyes = []
    true_home_eye = [0, 0, 0, 0, 0]
    stage_idx = [0, 0, 0, 0, 0]
    waiting_eyes = [0, 0, 0, 0, 0]
    all_waiting = false
    stage_string_array = [
    	"find_eye_change",
        "find_first_index_eye",
        "find_second_index_eye",
        "waiting",
        "rapid_home",
        "find_home_eye",
        "angle_in_eye",
		"complete",
        "direction_change"
    ]
    
    let default_thres = 2000
    cos_diff_thres = [default_thres, default_thres, default_thres, default_thres, default_thres]
    sin_diff_thres = [default_thres, default_thres, default_thres, default_thres, default_thres]
    eyes_between_sensors = [0, 0, 0, 0, 0]
    idx_eye_to_cal_offset = [0, 0, 0, 0, 0]
    
    /*
    if(scan_result){
        for(let i = 0; i < cos_diff_thres.length; i++){
            if(Object.keys(scan_result[i]).length != 0){
                cos_diff_thres[i] = scan_result[i].cos.ddx_thresh
                sin_diff_thres[i] = scan_result[i].sin.ddx_thresh
                eyes_between_sensors[i] = scan_result[i].sin_eye_offset
            }
        }
    }else{
    	warning("scan_result is undefined. Default thresholds will be used. (Ignore if running Initial_Scan)")
    }
    */
    
    //cos_to_center_block_offset = Vector.multiply(0.5, (Vector.multiply(deg_per_eye, Vector.add(-0.25, eyes_between_sensors))))
    cos_to_home_offset = [0, 0, 0, 0, 0]
    
    /*
    //OLD:
    neg_spacing_to_eye_offset = [
    	null,
        null,
        0,
        3,
        -2,
        8,
        -6,
        15,
        -12,
        24,
        -20,
        35,
        -30,
        48,
        -42,
        63
    ]
    
    pos_spacing_to_eye_offset = [
    	null,
        null,
        -2,
        0,
        -6,
        3,
        -12,
        8,
        -20,
        15,
        -30,
        24,
        -42
    ]
    */
    
    neg_spacing_to_eye_offset = [
    	null, //0
		null, //1
		null, //2
		null, //3
		0, 	  //4 (3 regular slots, 1 index, after seeing an index.)
		5,	  //5 (was at zero, moved past 4 regular, 1 index.)
		-4,	  //6
		12,	  //7
		-10,  //8
		21,	  //9
		-18,  //10
		32,	  //11
		-28,  //12
		45,	  //13
		-40,  //14
		60,	  //15
		-54,  //16
		77,	  //17
		-70,  //18
    ]
    
    pos_spacing_to_eye_offset = [
    	null,  //0
		null,  //1
		null,  //2
		null,  //3
		-4,    //4 (3 regular slots, 1 index, after seeing an index.)
		0,	   //5 (was at five, moved past 4 regular, 1 index.)
		-10,   //6
		5,	   //7
		-18,   //8
		12,	   //9
		-28,   //10
		21,	   //11
		-40,   //12
		32,	   //13
		-54,   //14
		45,	   //15
		-70,   //16
		60,	   //17
		-88,   //18
    ]
    
    /*
	let cw_spacing = -2
	let cw_spacing_inc = -4
	let ccw_spacing = 3
	let ccw_spacing_inc = 5
    let max_offset = Vector.max(n_eyes) / 2
    let i = 0
	while(Math.abs(spacing_to_eye_offset[i]) < max_offset){
        i++
        if(i%2 == 0){
            spacing_to_eye_offset.push(ccw_spacing)
            ccw_spacing += ccw_spacing_inc
            ccw_spacing_inc += 2
			
        }else{
            spacing_to_eye_offset.push(cw_spacing)
            cw_spacing += cw_spacing_inc
            cw_spacing_inc -= 2
        }
	}
    spacing_to_eye_offset.pop()
    spacing_to_eye_offset.pop()
    spacing_to_eye_offset[0] = null
    out("Generated spacing to eye offset:" + spacing_to_eye_offset)
	*/
    
   goal_angle_in_eye = [45, 45, 45, 45, 45]
   // idx_eye_to_cal_offset = [0, 0, 0, 0, 0]//Vector.subtract(info_post_calibration.eyes, info_raw_idx_eye.eyes)
}


//#D init_robot():
function init_robot(){
	return [
    	Dexter.set_parameter("MaxSpeed", 30),
    	Dexter.move_all_joints([0, 0, 0, 0, 0]), //remove this later
        Dexter.empty_instruction_queue(),
    	Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"),
        Dexter.read_from_robot("#RawEncoders", "RawEncoders"),
        Dexter.read_from_robot("/srv/samba/share/AdcCenters.txt", "AdcCenters"),
        function(){out("Attempting to read " + file_on_dexter_name + "...<br\>If Job errors, generate this file by running Inital_Scan and Save_Scan_Results", "blue")},
        Dexter.read_from_robot(file_on_dexter_name, "IndexEyeData"),
        Dexter.read_from_robot(file_on_dexter_name_post_cal, "PostCalInfo"),
        
        function(){
        	start_time = Date.now()
            
            
            start_EyeNumber = JSON.parse(this.user_data.EyeNumbers)
            old_EyeNumber = JSON.parse(this.user_data.EyeNumbers)
            //let temp = old_EyeNumber[4]
            //old_EyeNumber[4] = old_EyeNumber[2]
            //old_EyeNumber[2] = temp
            old_RawEncoder = JSON.parse(this.user_data.RawEncoders)
        	let AdcCenters_string = this.user_data.AdcCenters
            AdcCenters_array = AdcCenters_string_to_array(AdcCenters_string)
            
            
            scan_result = JSON.parse(this.user_data.IndexEyeData)
        	for(let i = 0; i < cos_diff_thres.length; i++){
            	if(Object.keys(scan_result[i]).length != 0){
                	cos_diff_thres[i] = scan_result[i].cos.ddx_thresh
                	sin_diff_thres[i] = scan_result[i].sin.ddx_thresh
                	eyes_between_sensors[i] = scan_result[i].sin_eye_offset
                    idx_eye_to_cal_offset[i] = scan_result[i].idx_eye_to_cal_offset
            	}
        	}

            post_cal_info = JSON.parse(this.user_data.PostCalInfo)
            /*
            //let AdcCenters_string_array = AdcCenters_string.split("\r\n")
            let temp_string = AdcCenters_string_array[4]
            AdcCenters_string_array[4] = AdcCenters_string_array[2]
            AdcCenters_string_array[2] = temp_string
            temp_string = AdcCenters_string_array[5]
            AdcCenters_string_array[5] = AdcCenters_string_array[3]
            AdcCenters_string_array[3] = temp_string
            */
            
            print_stages()
            /*
            let saved_x = parseInt(centers_string[2*(showing_J_num-1)]) / 655360
    		let saved_y = parseInt(centers_string[2*(showing_J_num-1)+1]) / 655360
            
            centers_string[2*window.cal_working_axis] =
                "0x" + ((vals.offsetX  * 10) * 65536).toString(16)
            centers_string[2*window.cal_working_axis+1] =
                "0x" + ((y_val_to_save * 10) * 65536).toString(16)
            */
            
        }
    ]
}


//#E find_idx_eyes():
function find_idx_eyes(){
	return Robot.loop(
    	function(){
        	
            for(let i = 0; i < stage_idx.length; i++){
            	if(stage_string_array[stage_idx[i]] != "complete"){
                	return true
                }
			}
            /*
            if(stage_string_array[stage_idx[0]] == "complete" && stage_string_array[stage_idx[1]] == "complete" && stage_string_array[stage_idx[4]] == "complete"){
            	return false
            }
            return true
            */
            return false
    	}, 
    function(){
    	let CMD = []
    	CMD.push(Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"))
        CMD.push(Dexter.read_from_robot("#RawEncoders", "RawEncoders"))
        CMD.push(Dexter.empty_instruction_queue())
        CMD.push(function(){
        	
        	EyeNumber = JSON.parse(this.user_data.EyeNumbers)
            //bug in #EyeNumber where joints are switched:
            //let temp = EyeNumber[4]
            //EyeNumber[4] = EyeNumber[2]
            //EyeNumber[2] = temp
            
        	let rs = this.robot.robot_status
            let cos_val = [
            	rs[Dexter.J1_A2D_COS],
                rs[Dexter.J2_A2D_COS],
                rs[Dexter.J3_A2D_COS],
                rs[Dexter.J4_A2D_COS],
                rs[Dexter.J5_A2D_COS]
            ]
            let sin_val = [
            	rs[Dexter.J1_A2D_SIN],
                rs[Dexter.J2_A2D_SIN],
                rs[Dexter.J3_A2D_SIN],
                rs[Dexter.J4_A2D_SIN],
                rs[Dexter.J5_A2D_SIN]
            ]
            
            if(
            	stage_string_array[stage_idx[0]] == "waiting" &&
            	stage_string_array[stage_idx[1]] == "waiting" &&
                stage_string_array[stage_idx[2]] == "waiting" &&
                stage_string_array[stage_idx[3]] == "waiting" &&
                stage_string_array[stage_idx[4]] == "waiting"
            ){
            	all_waiting = true
            }
            
            let max_val = 4096
            //if(cos_val[i] > max_val){cos_val[i] = -Infinity} //wierd bug where this would jump to large value. maybe electrical shorts?? EDIT: bug in read_from_robot that overwrites robot status
			let stage
            for(let i = 0; i < EyeNumber.length; i++){
            	//check raw vs commanded for collisions here
                
                
                stage = stage_string_array[stage_idx[i]]
                if(stage == "find_eye_change"){
                	if(EyeNumber[i] != old_EyeNumber[i]){
                    	step_size[i] = cur_direction[i]*Math.abs(deg_per_eye[i]/rapid_steps_per_eye[i]) //fast step speed
                    	stage_idx[i]++ //go to next stage
                        cos_maxes[i] = []
                        print_stages()
                  	}
                }else if(stage == "find_first_index_eye" || stage == "find_second_index_eye"){
                    all_cos_vals[i].push(cos_val[i])
                	all_sin_vals[i].push(sin_val[i])
                	all_eyes[i].push(EyeNumber[i])
                    
                    if(EyeNumber[i] == old_EyeNumber[i]){
                        prev_eye_cos_vals[i].push(cos_val[i])
                        prev_eye_sin_vals[i].push(sin_val[i])
                    }else if(prev_eye_cos_vals[i].length > 0){
                    	cos_maxes[i].push(local_max(prev_eye_cos_vals[i]))
                    	sin_maxes[i].push(local_max(prev_eye_sin_vals[i]))
                        prev_eye_cos_vals[i] = []
                        prev_eye_sin_vals[i] = []
                        /*if(cos_maxes[i].length > max_eye_spacing[i]){
                        	out("max_eye_spacing of " + cos_maxes[i].length + " exceeded for J" + (i + 1))
                            step_size[i] = -deg_per_eye[i] * (EyeNumber[i] - start_EyeNumber[i] - 2*Math.sign(EyeNumber[i] - start_EyeNumber[i]))
                            stage_idx[i] = stage_string_array.indexOf("direction_change")
                            print_stages()
                        }else */
                        if(cos_maxes[i].length > 2){ //needs at least three maxes
                        	//if(i==0){debugger}
                            if(is_idx_eye(cos_maxes[i], cos_diff_thres[i])){
                            	if(stage == "find_first_index_eye"){
                                	first_idx_eye[i] = EyeNumber[i] - 2 * cur_direction[i] //triggers on n+1 eyes and idx is middle of 3 eyes
                                    // /step_size[i] = (255 - EyeNumber[i]) - cur_direction[i]*2
                                    // /cur_direction[i] *= -1 
                                    
                                    
                                    stage_idx[i]++ //go to next stage
                                    print_stages()
                                }else{
                                	//if(i==2){debugger}
                                    waiting_eyes[i] = EyeNumber[i]
                                	stage_idx[i]++ //go to next stage
                        			print_stages()
                                }
                            }   
                        }
					}
                }else if(stage == "waiting"){
                    if(all_waiting){
                        second_idx_eye[i] = waiting_eyes[i] - 2 * cur_direction[i]
                        spacing_idx[i] = second_idx_eye[i] - first_idx_eye[i]
                        
                        //sign correction can be removed by flipping the code disk design
                        let sign_correction = [1, -1, 1, 1, 1]
                        //if(i==0){debugger}
                        if(sign_correction[i]*Math.sign(cur_direction[i]) == 1){
                        	final_eye_offset[i] = pos_spacing_to_eye_offset[Math.abs(spacing_idx[i])] + idx_eye_to_cal_offset[i]
                      	}else{
                        	final_eye_offset[i] = neg_spacing_to_eye_offset[Math.abs(spacing_idx[i])] + idx_eye_to_cal_offset[i]
                      		if(isNaN(final_eye_offset[i])){debugger}
                        }
                        if(i==1){final_eye_offset[1] *= -1}
                        
                      	true_home_eye[i] = second_idx_eye[i] + final_eye_offset[i]
                        step_size[i] = deg_per_eye[i] * (final_eye_offset[i] + Math.sign(EyeNumber[i] - start_EyeNumber[i]))
                        cur_direction[i] *= -1
                        stage_idx[i]++ //go to next stage
                        print_stages()
                    }else{
                    	if(EyeNumber[i] == waiting_eyes[i]){
                        	let x = cos_val[i] - AdcCenters_array[i][1]
                			let y = sin_val[i] - AdcCenters_array[i][0]
                			let atan2_val = atan2d(x, y)
                            step_size[i] = (-atan2_val) / 360 * deg_per_eye[i]
                        }else{
                        	step_size[i] = (waiting_eyes[i] - EyeNumber[i]) * deg_per_eye[i]
                        }
                    }
                }else if(stage == "rapid_home"){
                	step_size[i] = cur_direction[i]*Math.abs(deg_per_eye[i]/rapid_steps_per_eye[i])
                	stage_idx[i]++ //go to next stage
                    print_stages()
                }else if(stage == "find_home_eye"){
                	if(EyeNumber[i] == true_home_eye[i]){
                    	step_size[i] = 0
                		stage_idx[i]++ //go to next stage
                    	print_stages()
                    }else{
                    	cur_direction[i] = Math.sign(true_home_eye[i] - EyeNumber[i])
                    	step_size[i] = cur_direction[i]*Math.abs(deg_per_eye[i]/rapid_steps_per_eye[i])
                    }
                }else if(stage == "angle_in_eye"){
                	//let cal_atan2 = post_cal_info.atan2[i]
                	let cal_atan2 = goal_angle_in_eye[i]
                
                	let x = cos_val[i] - AdcCenters_array[i][1]
                	let y = sin_val[i] - AdcCenters_array[i][0]
                	let atan2_val = atan2d(x, y)
                	//out("eye: " + EyeNumber[i] + " atan2_val: " + Vector.round(atan2_val, 2) + " cos: " + x + " sin: " + y + " cmd_angle: " + Vector.round(cur_commanded_pos, 3)[i])
                	/*
                    if(atan2_val == info_post_calibration.atan2[i]){ //replace '0' with variable
                		step_size[i] = 0
                        stage_idx[i]++ //go to next stage
                    	print_stages()
                    }else{
                    	step_size[i] = (info_post_calibration.atan2[i] - atan2_val) / 360 * deg_per_eye[i]
                    }
                    */
                    let J_angle_thresh = 10 * _arcsec
					let E_angle_thresh = 360 * J_angle_thresh / deg_per_eye[i]
                    if(i == 0){
                    	out(
                        	"J" + i + 
                            " Target Eye:" + true_home_eye[i] + 
                            " Actual Eye:" + EyeNumber[i] + 
                            " target atan2: " + Vector.round(cal_atan2, 3) + 
                            " actual atan2: " + Vector.round(atan2_val, 3) + 
                            " error: " + Vector.round(cal_atan2 - atan2_val, 3) +
                            " arcsec error: " + Math.round((cal_atan2 - atan2_val)/ 360 * deg_per_eye[1] / _arcsec)
                        )
                    }
                    if(Math.abs(cal_atan2 - atan2_val) < E_angle_thresh && true_home_eye[i] == EyeNumber[i]){ //replace '0' with variable
                		step_size[i] = 0
                        stage_idx[i]++ //go to next stage
                    	print_stages()
                    }else{
                        // (true_home_eye[i] - EyeNumber[i]) * deg_per_eye[i] 
                    	step_size[i] = 0.25*((cal_atan2 - atan2_val) / 360 * deg_per_eye[i] + (true_home_eye[i] - EyeNumber[i]) * deg_per_eye[i])
                    }
                    
                }else if(stage == "complete"){
                	step_size[i] = 0
                    //load tables??
                }else if(stage == "direction_change"){
                	dde_error("direction_change stage not written yet")
                }else{
                	dde_error("Invalid stage: " + stage + " for J" + (i+1) + ", stage_idx: " + stage_idx[i]) 
                }   
            }
            old_EyeNumber = EyeNumber
        })
        CMD.push(function(){return Dexter.move_all_joints(cur_commanded_pos = Vector.add(step_size, cur_commanded_pos))})
        CMD.push(Dexter.empty_instruction_queue())

        return CMD
    })
}


//#E1 is_idx_eye():
function is_idx_eye(maxes, diff_threshold){
	let max_new = maxes[maxes.length - 1]
    let max_cur = maxes[maxes.length - 2]
    let max_old = maxes[maxes.length - 3]
    let cos_diff_old = max_cur - max_old
    let cos_diff_new = max_new - max_cur
    let ddx = cos_diff_new - cos_diff_old
    if(ddx > diff_threshold && cos_diff_old < 0 && cos_diff_new > 0){
    	return true
    }else{
    	return false
    }
    
    /*
	if(cos_diff_old < -diff_threshold && cos_diff_new > diff_threshold){
    	return true
    }else{
    	return false
    }
    */
}


//#E2 AdcCenters string conversions:
function AdcCenters_string_to_array(AdcCenters_string){
    let AdcCenters_string_array = AdcCenters_string.split("\r\n")
    let temp_string = AdcCenters_string_array[4]
    AdcCenters_string_array[4] = AdcCenters_string_array[2]
    AdcCenters_string_array[2] = temp_string
    temp_string = AdcCenters_string_array[5]
    AdcCenters_string_array[5] = AdcCenters_string_array[3]
    AdcCenters_string_array[3] = temp_string
	let AdcCenters_array = []
    for(let i = 0; i < 10; i+=2){
    	AdcCenters_array.push([
        	parseInt(AdcCenters_string_array[i]) / 65536,
            parseInt(AdcCenters_string_array[i+1]) / 65536
        ])
    }
    return AdcCenters_array
}

function AdcCenters_array_to_string(AdcCenters_array){
	let AdcCenters_string_array = []
    for(let i = 0; i < 5; i++){
    	AdcCenters_string_array.push("0x" + (AdcCenters_array[i][0] * 65536).toString(16))
        AdcCenters_string_array.push("0x" + (AdcCenters_array[i][1] * 65536).toString(16))
    }
    let temp_string = AdcCenters_string_array[4]
    AdcCenters_string_array[4] = AdcCenters_string_array[2]
    AdcCenters_string_array[2] = temp_string
    temp_string = AdcCenters_string_array[5]
    AdcCenters_string_array[5] = AdcCenters_string_array[3]
    AdcCenters_string_array[3] = temp_string
    let AdcCenters_string = ""
    for(let i = 0; i < AdcCenters_string_array.length; i++){
    	AdcCenters_string += AdcCenters_string_array[i] + "\r\n"
    }
    return AdcCenters_string
}

//#E3 print_stages():
function print_stages(){
	let str = ""
    for(let i = 0; i < stage_idx.length-1; i++){
    	str += stage_string_array[stage_idx[i]] + " | "
    }
    str += stage_string_array[stage_idx[stage_idx.length-1]]
	out(str, "blue")
}

//#F set_found_position():
function set_found_position(){
	
	//final_angle_offset = Vector.add(cur_commanded_pos, Vector.add(Vector.multiply(1, Vector.multiply(Vector.add(0, final_eye_offset), deg_per_eye)), cos_to_center_block_offset))
    //out("true_home: " + Vector.round(final_angle_offset, 2) + " final_eye_offset: " + final_eye_offset)
    //return Dexter.move_all_joints(final_angle_offset)
    
    /*
    final_angle_offset = Vector.add(cur_commanded_pos, Vector.add(Vector.multiply(1, Vector.multiply(Vector.add(0, final_eye_offset), deg_per_eye)), cos_to_center_block_offset))
	
     
    let new_EyeNumbers = Vector.subtract([255, 255, 255, 255, 255], final_eye_offset)
    let EyeNumber = JSON.parse(this.user_data.EyeNumbers)
    //bug in #EyeNumber where joints are switched:
    let temp = EyeNumber[4]
    EyeNumber[4] = EyeNumber[2]
    EyeNumber[2] = temp
	*/
    rs = this.robot.robot_status
    
    /*
    return [
    	Dexter.set_parameter("EyeNumbers", new_EyeNumbers)
    ]
    */

	let i = 1
	plot_find_idx_eye_data(all_cos_vals[i], all_eyes[i], first_idx_eye[i], second_idx_eye[i], i)
}


/*
new Job({
	name: "Write_Dex_Files",
    inter_do_item_dur: idid,
    show_instructions: false,
    do_list: [
    	init_globals,
    	function(){
        	
        	//scan_result = process_scan_data(scan_data)
            //for(let i = 0; i < 5; i++){
            //	  scan_result[i].cos = {}
            //    scan_result[i].cos.ddx_thresh = 0
            //    scan_result[i].sin = {}
            //    scan_result[i].sin.ddx_thresh
            //    scan_result[i].sin_eye_offset = 0
            //    scan_result[i].idx_eye_to_cal_offset = 0
            //}
            
            post_cal_info = {
            	eyes: [0, 0, 0, 0, 0],
                cos: [0, 0, 0, 0, 0],
                sin: [0, 0, 0, 0, 0],
                atan2: [0, 0, 0, 0, 0],
                Adc: [0, 0, 0, 0, 0],
                PID_deltas: [0, 0, 0, 0, 0]
            }
			return [
            	//Dexter.write_to_robot(JSON.stringify(scan_result), file_on_dexter_name),
        		Dexter.write_to_robot(JSON.stringify(post_cal_info), file_on_dexter_name_post_cal)
            ]
        },
    	
    ]
})
*/

var start_time
var end_time
//This is moved here for sequential order of the Jobs

/*
new Job({
	name: "Initial_Scan",
    inter_do_item_dur: idid,
    show_instructions: false,
    do_list: [
    	function(){start_time = Date.now()},
    	
        
        init_globals,
        init_robot,
        function(){scan_data = [[], [], [], [], []]},
        
        
        Dexter.move_all_joints([0, 0, 0, 0, 0]),
        function(){scan_data[0] = []},
    	function(){return do_scan(0, [-180, 180], 360/n_eyes[0] / 15)},
		
        
        
		Dexter.move_all_joints([0, 0, 0, 0, 0]),
        function(){scan_data[1] = []},
        function(){return do_scan(1, [-100, 100], 360/n_eyes[1] / 15)},
		
        
        
        Dexter.move_all_joints([0, 0, 0, 0, 0]),
        function(){scan_data[2] = []},
        function(){return do_scan(2, [-135, 135], 360/n_eyes[2] / 15)},
        
        
        Dexter.move_all_joints([0, 0, 0, 0, 0]),
        function(){scan_data[3] = []},
        function(){return do_scan(3, [-95, 95], 360/n_eyes[3] / 15)},
        
        Dexter.move_all_joints([0, 0, 0, 0, 0]),
        function(){scan_data[4] = []},
        function(){return do_scan(4, [-150, 150], 360/n_eyes[4] / 15)},
        Dexter.move_all_joints([0, 0, 0, 0, 0]),
     	
        function(){
        	end_time = Date.now()
            out("Initial_Scan time: " + Vector.round(((end_time-start_time)/ 1000), 0) + " seconds")
        },
        
        
        function(){
        	scan_result = process_scan_data(scan_data)
            inspect(scan_result)
            //plot_scan_data(scan_data, scan_result, 1)
            
            for(let i = 0; i < 5; i++){
            	plot_scan_data(scan_data, scan_result, i)
            }
            
            
        }
	]
})
*/

/*
new Job({
	name: "Save_Scan_Results",
    inter_do_item_dur: 0,
    show_instructions: false,
    do_list: [
    	function(){
        	let content = JSON.stringify(scan_result)
			return Dexter.write_to_robot(content, file_on_dexter_name)
        }
    ]
})
*/


function check_button_press(){
	let CMD = []
    CMD.push(Dexter.write_to_robot("51", "/sys/class/gpio/export"))
    CMD.push(Dexter.write_to_robot("in", "/sys/class/gpio/gpio51/direction"))
    CMD.push(Dexter.read_from_robot("/sys/class/gpio/gpio51/value", "sw1"))
    CMD.push(Dexter.write_to_robot("51", "/sys/class/gpio/unexport"))
    
    CMD.push(function(){
    	let sw1 = this.user_data.sw1
        if(sw1 == 1){
    		out("Button is pressed, stopping this Find_Idx_Eyes Job and the Job Engine")
            return [
            	Dexter.set_parameter("MaxSpeed", 120),
            	Dexter.move_all_joints([0, 0, 0, 0, 0]),
                Dexter.move_all_joints([0, 0, 0, 30, 30]),
                Dexter.move_all_joints([0, 0, 0, 0, 0]),
                Dexter.set_parameter("MaxSpeed", 30),
                function(){
            		this.stop_for_reason("completed", "completed")
                }
            ]
        }else{
        	//out("Button is not pressed, continuing Find_Idx_Eyes")
        }
    })
    return CMD
}

function check_eye_order(){
	
    let num_eyes = 3
    let J_to_move = 0
    let angles = [0, 0, 0, 0, 0]
    angles[J_to_move] = num_eyes * deg_per_eye[J_to_move]
    
    return [
    	Dexter.move_all_joints([0, 0, 0, 0, 0]),
        Dexter.empty_instruction_queue(),
    	Dexter.read_from_robot("#EyeNumbers", "EyeNumbers_0"),
		Dexter.empty_instruction_queue(),
        Dexter.move_all_joints(angles),
        Dexter.empty_instruction_queue(),
        Dexter.read_from_robot("#EyeNumbers", "EyeNumbers_1"),
        Dexter.move_all_joints([0, 0, 0, 0, 0]),
        function(){
        	let EyeNum_0 = JSON.parse(this.user_data.EyeNumbers_0)
            let EyeNum_1 = JSON.parse(this.user_data.EyeNumbers_1)
            let EyeDiff = Vector.abs(Vector.subtract(EyeNum_1, EyeNum_0))
            
            out("EyeNum_0: " + EyeNum_0)
            out("EyeNum_1: " + EyeNum_1)
            out("EyeDiff: " + EyeDiff)
            
            let max = -Infinity
            let max_idx
            for(let i = 0; i < EyeDiff.length; i++){
            	if(EyeDiff[i] > max){
                	max = EyeDiff[i]
                    max_idx = i
                }
            }
            
            
            out("max: " + max +" max_idx: " + max_idx)
            
            if(max_idx != J_to_move){
            	out("EyeNumbers are out of order. Restarting the robot...")
                return [
                	Dexter.move_all_joints([0, 0, 0, 0, 0]),
                    Dexter.move_all_joints([0, 0, -10, 0, 0]),
                    Dexter.empty_instruction_queue,
                    Dexter.sleep(1),
                    //Dexter.move_all_joints([0, 0, 0, 0, 0]),
                    //Dexter.empty_instruction_queue,
                	//Dexter.read_from_robot("`shutdown -r now", "read_result"),
                    function(){
                    	out("Restart command sent.")
                    	this.stop_for_reason("completed", "completed")
                    }
                ]
            }
        }
    ]
}

var atan2_vals, atan2_goal, J_error_thres, E_error_thresh, J_error
function center_eye(){
	return [
    	function(){
        	J_error_thres = [2*_arcsec, 2*_arcsec, 2*_arcsec, 20*_arcsec, 20*_arcsec]
            
        	atan2_vals = [Infinity, Infinity, Infinity, Infinity, Infinity]
            atan2_goal = goal_angle_in_eye
            J_error = [Infinity, Infinity, Infinity, Infinity, Infinity]
            E_error_thresh = Vector.divide(Vector.multiply(360, J_error_thres), deg_per_eye)
        },
    	Robot.loop(
        	function(){
            
            	let result = false
                for(let i = 0; i < atan2_vals.length; i++){
                	if(!(Math.abs(J_error[i]) < J_error_thres[i])){
                    	result = true
                    }
                }
                return result
            },
            function(){
            	let CMD = []
                CMD.push(Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"))
                CMD.push(function(){EyeNumber = JSON.parse(this.user_data.EyeNumbers)}),
                CMD.push(Dexter.get_robot_status())
                CMD.push(function(){
                	let rs = this.robot.robot_status
            		let cos_val = [
            			rs[Dexter.J1_A2D_COS],
                		rs[Dexter.J2_A2D_COS],
                		rs[Dexter.J3_A2D_COS],
                		rs[Dexter.J4_A2D_COS],
                		rs[Dexter.J5_A2D_COS]
            		]
            		let sin_val = [
            			rs[Dexter.J1_A2D_SIN],
                		rs[Dexter.J2_A2D_SIN],
                		rs[Dexter.J3_A2D_SIN],
                		rs[Dexter.J4_A2D_SIN],
                		rs[Dexter.J5_A2D_SIN]
            		]
                    let cur_angles = [
            			rs[Dexter.J1_ANGLE],
                		rs[Dexter.J2_ANGLE],
                		rs[Dexter.J3_ANGLE],
                		rs[Dexter.J4_ANGLE],
                		rs[Dexter.J5_ANGLE]
            		]
                    
                    let x, y
                    let step = [0, 0, 0, 0, 0]
                    let str = ""
                    for(let i = 0; i < 5; i++){
            			x = cos_val[i] - AdcCenters_array[i][1]
                		y = sin_val[i] - AdcCenters_array[i][0]
                		atan2_vals[i] = atan2d(x, y)
                        atan2_error = atan2_goal[i] - atan2_vals[i]
                        J_error[i] = 0.25 * atan2_error * deg_per_eye[i] / 360
                        step[i] = J_error[i]
                        //str += "| " + EyeNumber[i] + ", " + Vector.round(atan2_error, 3) + ", " + Math.round(J_error[i]/_arcsec) + " "
                    	str += "| " + EyeNumber[i] + ", " + Math.round(J_error[i]/_arcsec) + " "
                    }
                    out(str, "blue")
                    return Dexter.move_all_joints(Vector.add(cur_angles, step))
                })
                CMD.push(Dexter.empty_instruction_queue())
                
                return CMD
            }
        ),
        Dexter.sleep(1),
            make_ins('w', FPGA.COMMAND_REG, FPGA.cmd_reg_val({
            	ResetMotorPosition: true,
        	})),
            make_ins('w', FPGA.COMMAND_REG, FPGA.cmd_reg_val({
            	ResetMotorPosition: false,
        	})),
            Dexter.empty_instruction_queue(),
            function(){out("Done")}
    ]
    
    
}

new Job({
	name: "Find_Idx_Eyes",
    inter_do_item_dur: idid,
    show_instructions: false,
    do_list: [
    	check_button_press,
    	init_globals,
        init_robot,
        
        check_button_press,
        check_eye_order,
        center_eye,
        
    	find_idx_eyes,
        Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"),
        function(){
			let cur_eyes = JSON.parse(this.user_data.EyeNumbers)
            idx_eye_to_cal_offset = Vector.subtract([255, 255, 255, 255, 255], cur_eyes)
            
        	out("Current eyes: " + JSON.stringify(cur_eyes))
            out("idx_eye_to_cal_offset: " + JSON.stringify(idx_eye_to_cal_offset))
            
        },
        reset_robot,
        Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"),
        function(){
			let cur_eyes = JSON.parse(this.user_data.EyeNumbers)
            idx_eye_to_cal_offset = Vector.subtract([255, 255, 255, 255, 255], cur_eyes)
            
        	out("Current eyes: " + JSON.stringify(cur_eyes))
            out("idx_eye_to_cal_offset: " + JSON.stringify(idx_eye_to_cal_offset))
            
        }
    ]
})





var all_starting_states = [
	90,
    66,
    48,
    30,
    18,
    10,
    4,
    0,
    -10,
    -24,
    -42,
    -64
]




var test_results = []

// is do_scan needed?

function do_scan(joint_num, range, step_size){
	let CMD = []
    //debugger
    let angles = [0, 0, 0, 0, 0]
    for(let theta = range[0]; theta < range[1]; theta+=step_size){
    	angles[joint_num] = theta
    	CMD.push(Dexter.move_all_joints(JSON.parse(JSON.stringify(angles))))
        CMD.push(Dexter.empty_instruction_queue())
        CMD.push(Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"))
        CMD.push(Dexter.read_from_robot("#RawEncoders", "RawEncoders"))
        CMD.push(Dexter.empty_instruction_queue())
        CMD.push(function(){
        	let rs = this.robot.rs.robot_status
            let eyes = JSON.parse(this.user_data.EyeNumbers)
            if(scan_data[joint_num].length > 0){
            	let old_eye = scan_data[joint_num][scan_data[joint_num].length-1].EyeNumber
                let diff = eyes[joint_num] - old_eye
            	if(diff < 0 || 1 < diff){
            		warning("Joint " + (joint_num + 1) + " is not calibratible. Failed at " + Vector.round(theta, 2) + " degrees. Eye: " + eyes[joint_num] + " old_Eye: " + old_eye)
            	}
            }
            let obj = {
                CmdAngle: theta,
                x: rs[Dexter["J" + (joint_num + 1) + "_A2D_COS"]],
                y: rs[Dexter["J" + (joint_num + 1) + "_A2D_SIN"]],
                EyeNumber: eyes[joint_num],
                RawEncoder: JSON.parse(this.user_data.RawEncoders)[joint_num],
                MeasuredAngle: rs[Dexter["J" + (joint_num + 1) + "_MEASURED_ANGLE"]] * _arcsec
            }
            scan_data[joint_num].push(obj)
        })
    }
    return CMD
}

function process_scan_data(scan_data){
	let elt
    let obj
    let first_eye_num, last_eye_num, old_eye_num, eye_num
    let x_vals, y_vals
    
    let x_all_data = [[], [], [], [], []]
    let y_all_data = [[], [], [], [], []]
    let x_maxes = [[], [], [], [], []]
    let y_maxes = [[], [], [], [], []]
    let result = [{}, {}, {}, {}, {}]
    for(let i = 0; i < scan_data.length; i++){
    	elt = scan_data[i]
        if(elt.length > 0){old_eye_num = elt[0].EyeNumber}
        x_vals = []
        y_vals = []
        for(let j = 0; j < elt.length; j++){
        	obj = elt[j]
            eye_num = obj.EyeNumber
            if(eye_num == old_eye_num){
            	x_vals.push(obj.x)
            	y_vals.push(obj.y)
            }else{
            	x_maxes[i].push(local_max(x_vals))
                y_maxes[i].push(local_max(y_vals))
                x_vals = []
                y_vals = []
                old_eye_num = eye_num
            }
        }
    }
    
    let x_second_derivative = [[], [], [], [], []]
    let y_second_derivative = [[], [], [], [], []]
    let prev, cur, next, first_derivative, sec_derivative
    for(let i = 0; i < scan_data.length; i++){
    	for(let j = 3; j < x_maxes[i].length-2; j++){
        	next = x_maxes[i][j]
            cur = x_maxes[i][j-1]
            prev = x_maxes[i][j-2]
            first_derivative = [cur - prev, next - cur]
            //sec_derivative = first_derivative[1] - first_derivative[0]
            
            //THIS MIGHT BREAK THINGS:
            if(first_derivative[0] > 0 || first_derivative[1] < 0){
            	sec_derivative = 0 // if it's not a local min it is disqualified
            }else{
            	sec_derivative = first_derivative[1] - first_derivative[0]
            }
            
            obj = {
            	val: sec_derivative,
                eye_num: scan_data[i][0].EyeNumber + j - 1
            }
            
            
            
        	x_second_derivative[i].push(obj)
        }
        for(let j = 3; j < y_maxes[i].length-2; j++){
        	next = y_maxes[i][j]
            cur = y_maxes[i][j-1]
            prev = y_maxes[i][j-2]
            first_derivative = [cur - prev, next - cur]
            sec_derivative = first_derivative[1] - first_derivative[0]
            obj = {
            	val: sec_derivative,
                eye_num: scan_data[i][0].EyeNumber + j - 1
            }
        	y_second_derivative[i].push(obj)
        }
        
        if(x_maxes[i].length > 0){
        	result[i].cos = calc_thresh(x_second_derivative[i])
        	result[i].sin = calc_thresh(y_second_derivative[i])
            result[i].sin_eye_offset = find_eye_offset(result[i].cos.idx_eye_nums, result[i].sin.idx_eye_nums)
            
            result[i].cos.maxes = x_maxes[i]
            result[i].sin.maxes = y_maxes[i]
        }
	}
    for(let i = 0; i < result.length; i++){
    	result[i].idx_eye_to_cal_offset = 0
    }
    
    return result
}

function local_max(vals){
	let max = -Infinity, elt
    for(let i = 1; i < vals.length-1; i++){
    	elt = vals[i]
    	if(vals[i] > max && 0 > ((vals[i+1] - elt) - (elt - vals[i-1]))){
        	max = elt
        }
    }
    return max
}

function calc_thresh(ddx){
	let ddx_unsorted = JSON.parse(JSON.stringify(ddx))
	ddx.sort(function(a, b){return b.val - a.val})
    let ddx_sorted = JSON.parse(JSON.stringify(ddx))
    let diff_min = Infinity
    let diff
    let val_before_drop
    let val_after_drop
    let idx_after_drop
    let buffer = 4
    for(let i = buffer; i < ddx.length-buffer; i++){
      	diff = ddx[i].val - ddx[i-1].val
      	//out(diff)
      	if(diff < diff_min){
        	val_before_drop = ddx[i-1].val
        	val_after_drop = ddx[i].val
        	idx_after_drop = i
        	diff_min = diff
      	}
    }
  	//out("val_before_drop: " + val_before_drop + " val_after_drop: " + val_after_drop + " idx_after_drop: " + idx_after_drop)
	let thresh = (val_before_drop + val_after_drop) / 2
    
  	let ddx_top = ddx.slice(0, idx_after_drop)
  	ddx_top.sort(function(a, b){return a.eye_num - b.eye_num})
  	let spacing_array = []
    let idx_eye_nums = [ddx_top[0].eye_num]
    
  	for(let i = 1; i < ddx_top.length; i++){
    	idx_eye_nums.push(ddx_top[i].eye_num)
    	spacing_array.push(ddx_top[i].eye_num - ddx_top[i - 1].eye_num)
  	}
  	//out(spacing_array)
    
    return {
    	ddx_thresh: thresh,
        num_idx_eyes: spacing_array.length + 1,
        spacing: spacing_array,
        //ddx_idx_max: Vector.max(ddx_top),
        ddx_idx_min: val_before_drop,
        ddx_non_idx_max: val_after_drop,
        idx_eye_nums: idx_eye_nums,
        ddx_unsorted: ddx_unsorted,
        ddx_sorted: ddx_sorted,
        val_before_drop: val_before_drop,
        val_after_drop: val_after_drop
    }
}


function find_eye_offset(cos_eyes, sin_eyes){
	let offset = null
    let sin_elt, cos_elt, sub
    for(let i = 1; i < cos_eyes.length; i++){
    	sin_elt = [sin_eyes[i], sin_eyes[i-1]]
        for(let j = 1; j < cos_eyes.length; j++){
        	cos_elt = [cos_eyes[j], cos_eyes[j-1]]
            sub = Vector.subtract(sin_elt, cos_elt)
            if(sub[0] == sub[1]){
            	offset = sub[0]
            }
        }
    }
    return offset
}



function copy(variable){
	return JSON.parse(JSON.stringify(variable))
}


var FPGA = {
	BASE_POSITION: 0,
    END_POSITION: 1,
    PIVOT_POSITION: 2,
    ANGLE_POSITON: 3,
    ROT_POSITION: 4,
    ACCELERATION_MAXSPEED: 5,
    BASE_SIN_CENTER: 6,
    BASE_COS_CENTER: 7,
    END_SIN_CENTER: 8,
    END_COS_CENTER: 9,
    PIVOT_SIN_CENTER: 10,
    PIVOT_COS_CENTER: 11,
    ANGLE_SIN_CENTER: 12,
    ANGLE_COS_CENTER: 13,
    ROT_SIN_CENTER: 14,
    ROT_COS_CENTER: 15,
    PID_DELTATNOT: 16,
    PID_DELTAT: 17,
    PID_D: 18,
    PID_I: 19,
    PID_P: 20,
    PID_ADDRESS: 21,
    BOUNDRY_BASE: 22,
    BOUNDRY_END: 23,
    BOUNDRY_PIVOT: 24,
    BOUNDRY_ANGLE: 25,
    BOUNDRY_ROT: 26,
    SPEED_FACTORA: 27,
    SPEED_FACTORB: 28,
    FRICTION_BASE: 29,
    FRICTION_END: 30,
    FRICTION_PIVOT: 31,
    FRICTION_ANGLE: 32,
    FRICTION_ROT: 33,
    MOVE_TRHESHOLD: 34,
    F_FACTOR: 35,
    MAX_ERROR: 36,
    FORCE_BIAS_BASE: 37,
    FORCE_BIAS_END: 38,
    FORCE_BIAS_PIVOT: 39,
    FORCE_BIAS_ANGLE: 40,
    FORCE_BIAS_ROT: 41,
    COMMAND_REG: 42,
    DMA_CONTROL: 43,
    DMA_WRITE_DATA: 44,
    DMA_WRITE_PARAMS: 45,
    DMA_WRITE_ADDRESS: 46,
    DMA_READ_PARAMS: 47,
    DMA_READ_ADDRESS: 48,
    REC_PLAY_CMD: 49,
    REC_PLAY_TIMEBASE: 50,
    DIFF_FORCE_TIMEBASE: 51,
    DIFF_FORCE_BETA: 52,
    DIFF_FORCE_MOVE_THRESHOLD: 53,
    DIFF_FORCE_MAX_SPEED: 54,
    DIFF_FORCE_SPEED_FACTOR_ANGLE: 55,
    DIFF_FORCE_SPEED_FACTOR_ROT: 56,
    DIFF_FORCE_ANGLE_COMPENSATE: 57,
    FINE_ADJUST_BASE: 58,
    FINE_ADJUST_END: 59,
    FINE_ADJUST_PIVOT: 60,
    FINE_ADJUST_ANGLE: 61,
    FINE_ADJUST_ROT: 62,
    RECORD_LENGTH: 63,
    END_EFFECTOR_IO: 64,
    SERVO_SETPOINT_A: 65,
    SERVO_SETPOINT_B: 66,
    BASE_FORCE_DECAY: 67,
    END_FORCE_DECAY: 68,
    PIVOT_FORCE_DECAY: 69,
    ANGLE_FORCE_DECAY: 70,
    ROTATE_FORCE_DECAY: 71,
    PID_SCHEDULE_INDEX: 72,
    GRIPPER_MOTOR_CONTROL: 73,
    GRIPPER_MOTOR_OFF_WIDTH: 74,
    GRIPPER_MOTOR_ON_WIDTH: 75,
    START_SPEED: 76,
    ANGLE_END_RATIO: 77,
    CMD2: 78,
    PID_TIMEBASE: 79,
    PHYSICS_XYZ_TIMEBASE: 80,
    PHYSICS_DIFF_TIMEBASE: 81
}

FPGA.cmd_reg_val = function({
	CapCalibrateBase = false,
    CapCalibrateEnd = false,
    CapCalibratePivot = false,
    MoveEnable = false,
    GoMove = false,
    EnableLoop = false,
    AClrLoop = false,
    CAL_RUN = false,
    ResetMotorPosition = false,
    ResetForce = false,
    CapCalAngle = false,
    CapCalRot = false,
    AngleEnable = false,
    RotEnable = false,
}={}){
	let result = 0
    if(CapCalibrateBase){   result += 1}
    if(CapCalibrateEnd){    result += 2}
    if(CapCalibratePivot){  result += 4}
    if(MoveEnable){         result += 8}
    if(GoMove){             result += 16}
    if(EnableLoop){         result += 32}
    if(AClrLoop){           result += 64}
    if(CAL_RUN){            result += 128}
    if(ResetMotorPosition){ result += 256}
    if(ResetForce){         result += 512}
    if(CapCalAngle){        result += 1024}
    if(CapCalRot){          result += 2048}
    if(AngleEnable){        result += 4096}
    if(RotEnable){          result += 8192}
    return result
}

FPGA.cmd_reg_val({
	EnableLoop: true,
    CAL_RUN: true,
    ResetForce: true,
    AngleEnable: true,
    RotEnable: true
})

function reset_robot(){
	return [
    	make_ins('w', FPGA.COMMAND_REG, FPGA.cmd_reg_val({
        	AClrLoop: true,
            ResetMotorPosition: true,
            ResetForce:true
        })),
        make_ins('w', FPGA.COMMAND_REG, FPGA.cmd_reg_val()),
        
        make_ins('w', FPGA.CMD2, 7),
        make_ins('w', FPGA.CMD2, 0),
        
        make_ins('w', FPGA.PID_TIMEBASE, 86),
        make_ins('w', FPGA.PID_TIMEBASE, 86),
        make_ins('w', FPGA.PHYSICS_XYZ_TIMEBASE, 86),
        make_ins('w', FPGA.PHYSICS_DIFF_TIMEBASE, 172),
        
        make_ins('w', FPGA.DIFF_FORCE_BETA, 177),
        make_ins('w', FPGA.SPEED_FACTORB, 90),
		
        Dexter.sleep(0.5),
        Dexter.set_parameter("MaxSpeed", 30),
        Dexter.move_all_joints([0, 0, 0, 0, 0]),
        Dexter.move_all_joints([6, 6, 6, 6, 6]),
        Dexter.move_all_joints([0, 0, 0, 0, 0]),
        
        Dexter.empty_instruction_queue(),
        
        make_ins('w', FPGA.COMMAND_REG, FPGA.cmd_reg_val({
			EnableLoop: true,
    		CAL_RUN: true,
    		ResetForce: true,
    		AngleEnable: true,
    		RotEnable: true
		})),
        //make_ins('w', FPGA.COMMAND_REG, FPGA.cmd_reg_val()),
        
        Dexter.set_parameter("J1BoundryLow", -150),
        Dexter.set_parameter("J1BoundryHigh", 150),
        Dexter.set_parameter("J2BoundryLow", -90),
        Dexter.set_parameter("J2BoundryHigh", 90),
        Dexter.set_parameter("J3BoundryLow", -150),
        Dexter.set_parameter("J3BoundryHigh", 150),
        Dexter.set_parameter("J4BoundryLow", -90),
        Dexter.set_parameter("J4BoundryHigh", 90),
        Dexter.set_parameter("J5BoundryLow", -140),
        Dexter.set_parameter("J5BoundryHigh", 140),
        
        Dexter.sleep(0.5),
        Dexter.set_keep_position(),
    ]
}


//var atan2_vals, atan2_goal, J_error_thres, E_error_thresh, J_error
